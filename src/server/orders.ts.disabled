/**
 * Order Server Functions
 *
 * Server-side functions for order operations.
 * Uses Drizzle ORM with Zod validation.
 */

import { createServerFn } from "@tanstack/react-start";
import { eq, and, desc, asc, sql, gte, lte } from "drizzle-orm";
import { db } from "@/lib/db";
import { orders, orderLineItems, customers, products } from "@/../drizzle/schema";
import {
  createOrderSchema,
  updateOrderSchema,
  orderListQuerySchema,
  orderParamsSchema,
  updateOrderStatusSchema,
} from "@/lib/schemas/orders";

// ============================================================================
// HELPER: Calculate order totals
// ============================================================================

function calculateOrderTotals(
  lineItems: Array<{
    quantity: number;
    unitPrice: number;
    discountAmount?: number;
    taxType: string;
  }>,
  orderDiscount: number = 0,
  shippingAmount: number = 0
) {
  let subtotal = 0;
  let taxAmount = 0;

  for (const item of lineItems) {
    const lineSubtotal = item.quantity * item.unitPrice - (item.discountAmount ?? 0);
    subtotal += lineSubtotal;

    // Calculate tax (GST = 10% in Australia)
    if (item.taxType === "gst") {
      taxAmount += lineSubtotal * 0.1;
    }
  }

  const total = subtotal - orderDiscount + taxAmount + shippingAmount;

  return {
    subtotal,
    discountAmount: orderDiscount,
    taxAmount,
    shippingAmount,
    total,
    balanceDue: total, // Initially, balance due equals total
  };
}

// ============================================================================
// GET ORDERS (List with pagination and filters)
// ============================================================================

export const getOrders = createServerFn({ method: "GET" })
  .inputValidator(orderListQuerySchema)
  .handler(async ({ data }) => {
    const {
      page,
      pageSize,
      sortBy,
      sortOrder,
      search,
      status,
      paymentStatus,
      customerId,
      minTotal,
      maxTotal,
    } = data;

    // Build where conditions
    const conditions = [];

    // TODO: Add organizationId filter from session context
    // conditions.push(eq(orders.organizationId, ctx.organizationId));

    if (search) {
      conditions.push(sql`${orders.orderNumber} ILIKE ${"%" + search + "%"}`);
    }
    if (status) {
      conditions.push(eq(orders.status, status));
    }
    if (paymentStatus) {
      conditions.push(eq(orders.paymentStatus, paymentStatus));
    }
    if (customerId) {
      conditions.push(eq(orders.customerId, customerId));
    }
    if (minTotal !== undefined) {
      conditions.push(gte(orders.total, minTotal));
    }
    if (maxTotal !== undefined) {
      conditions.push(lte(orders.total, maxTotal));
    }

    // Soft delete filter
    conditions.push(sql`${orders.deletedAt} IS NULL`);

    // Build query
    const whereClause =
      conditions.length > 0 ? and(...conditions) : undefined;

    // Get total count
    const countResult = await db
      .select({ count: sql<number>`count(*)` })
      .from(orders)
      .where(whereClause);
    const totalItems = Number(countResult[0]?.count ?? 0);

    // Get paginated results
    const offset = (page - 1) * pageSize;
    const orderColumn =
      sortBy === "orderNumber"
        ? orders.orderNumber
        : sortBy === "total"
          ? orders.total
          : sortBy === "orderDate"
            ? orders.orderDate
            : orders.createdAt;
    const orderDirection = sortOrder === "asc" ? asc : desc;

    const items = await db
      .select({
        order: orders,
        customer: {
          id: customers.id,
          name: customers.name,
          email: customers.email,
        },
      })
      .from(orders)
      .leftJoin(customers, eq(orders.customerId, customers.id))
      .where(whereClause)
      .orderBy(orderDirection(orderColumn))
      .limit(pageSize)
      .offset(offset);

    return {
      items: items.map((row) => ({
        ...row.order,
        customer: row.customer,
      })),
      pagination: {
        page,
        pageSize,
        totalItems,
        totalPages: Math.ceil(totalItems / pageSize),
      },
    };
  });

// ============================================================================
// GET ORDER BY ID (with line items)
// ============================================================================

export const getOrderById = createServerFn({ method: "GET" })
  .inputValidator(orderParamsSchema)
  .handler(async ({ data }) => {
    const { id } = data;

    // Get order with customer
    const orderResult = await db
      .select({
        order: orders,
        customer: {
          id: customers.id,
          name: customers.name,
          email: customers.email,
        },
      })
      .from(orders)
      .leftJoin(customers, eq(orders.customerId, customers.id))
      .where(and(eq(orders.id, id), sql`${orders.deletedAt} IS NULL`))
      .limit(1);

    if (orderResult.length === 0) {
      throw new Error("Order not found");
    }

    // Get line items with product info
    const lineItemsResult = await db
      .select({
        lineItem: orderLineItems,
        product: {
          id: products.id,
          name: products.name,
          sku: products.sku,
        },
      })
      .from(orderLineItems)
      .leftJoin(products, eq(orderLineItems.productId, products.id))
      .where(eq(orderLineItems.orderId, id))
      .orderBy(asc(orderLineItems.lineNumber));

    return {
      ...orderResult[0].order,
      customer: orderResult[0].customer,
      lineItems: lineItemsResult.map((row) => ({
        ...row.lineItem,
        product: row.product,
      })),
    };
  });

// ============================================================================
// CREATE ORDER
// ============================================================================

export const createOrder = createServerFn({ method: "POST" })
  .inputValidator(createOrderSchema)
  .handler(async ({ data }) => {
    const { lineItems, ...orderData } = data;

    // TODO: Get organizationId from session context
    const organizationId = "00000000-0000-0000-0000-000000000000"; // Placeholder

    // Generate order number if not provided
    const orderNumber =
      orderData.orderNumber ??
      `ORD-${Date.now().toString(36).toUpperCase()}`;

    // Calculate totals
    const totals = calculateOrderTotals(
      lineItems.map((item) => ({
        quantity: item.quantity,
        unitPrice: item.unitPrice,
        discountAmount: item.discountAmount,
        taxType: item.taxType,
      })),
      orderData.discountAmount ?? 0,
      orderData.shippingAmount ?? 0
    );

    // Create order
    const [order] = await db
      .insert(orders)
      .values({
        ...orderData,
        orderNumber,
        organizationId,
        ...totals,
        paidAmount: 0,
      })
      .returning();

    // Create line items
    if (lineItems.length > 0) {
      const lineItemsToInsert = lineItems.map((item, index) => {
        const lineSubtotal =
          item.quantity * item.unitPrice - (item.discountAmount ?? 0);
        const taxAmount = item.taxType === "gst" ? lineSubtotal * 0.1 : 0;

        return {
          organizationId,
          orderId: order.id,
          lineNumber: item.lineNumber ?? `${index + 1}`,
          productId: item.productId,
          sku: item.sku,
          description: item.description,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          discountPercent: item.discountPercent ?? 0,
          discountAmount: item.discountAmount ?? 0,
          taxType: item.taxType,
          taxAmount,
          lineTotal: lineSubtotal + taxAmount,
          notes: item.notes,
        };
      });

      await db.insert(orderLineItems).values(lineItemsToInsert);
    }

    return order;
  });

// ============================================================================
// UPDATE ORDER STATUS
// ============================================================================

export const updateOrderStatus = createServerFn({ method: "POST" })
  .inputValidator(orderParamsSchema.merge(updateOrderStatusSchema))
  .handler(async ({ data }) => {
    const { id, status } = data;

    // Get date fields based on status
    const statusDates: Record<string, Date | null> = {};
    if (status === "shipped") {
      statusDates.shippedDate = new Date();
    } else if (status === "delivered") {
      statusDates.deliveredDate = new Date();
    }

    const result = await db
      .update(orders)
      .set({
        status,
        ...statusDates,
      })
      .where(and(eq(orders.id, id), sql`${orders.deletedAt} IS NULL`))
      .returning();

    if (result.length === 0) {
      throw new Error("Order not found");
    }

    return result[0];
  });

// ============================================================================
// UPDATE ORDER
// ============================================================================

export const updateOrder = createServerFn({ method: "POST" })
  .inputValidator(orderParamsSchema.merge(updateOrderSchema))
  .handler(async ({ data }) => {
    const { id, ...updateData } = data;

    const result = await db
      .update(orders)
      .set(updateData)
      .where(and(eq(orders.id, id), sql`${orders.deletedAt} IS NULL`))
      .returning();

    if (result.length === 0) {
      throw new Error("Order not found");
    }

    return result[0];
  });

// ============================================================================
// DELETE ORDER (Soft Delete)
// ============================================================================

export const deleteOrder = createServerFn({ method: "POST" })
  .inputValidator(orderParamsSchema)
  .handler(async ({ data }) => {
    const { id } = data;

    const result = await db
      .update(orders)
      .set({ deletedAt: new Date() })
      .where(and(eq(orders.id, id), sql`${orders.deletedAt} IS NULL`))
      .returning();

    if (result.length === 0) {
      throw new Error("Order not found");
    }

    return { success: true };
  });
