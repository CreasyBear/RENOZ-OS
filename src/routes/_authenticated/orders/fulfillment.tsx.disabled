/**
 * Order Fulfillment Route
 *
 * SOTA SaaS kanban board for order fulfillment workflow.
 * Enhanced with error boundaries, performance monitoring, and advanced filtering.
 *
 * @see _Initiation/_prd/2-domains/orders/orders.prd.json (ORD-FULFILLMENT-DASHBOARD)
 * @see _development/_audit/prd_reference/plans/plan-fulfillment-kanban-greenfield.md
 */

import { createFileRoute, useNavigate } from "@tanstack/react-router";
import React, { useState, useCallback, useMemo, useEffect, Profiler, Suspense, lazy } from "react";
import { PageLayout } from "@/components/layout";
import { Button } from "@/components/ui/button";
import { FulfillmentDashboard, useOrderInlineEdit } from "@/components/domain/orders";

// Lazy-loaded dialog components for bundle optimization
const OrderCreateDialog = lazy(() => import("@/components/domain/orders").then(m => ({ default: m.OrderCreateDialog })));
const OrderEditDialog = lazy(() => import("@/components/domain/orders").then(m => ({ default: m.OrderEditDialog })));
const OrderBulkOperationsDialog = lazy(() => import("@/components/domain/orders").then(m => ({ default: m.OrderBulkOperationsDialog })));
const ShipOrderDialog = lazy(() => import("@/components/domain/orders").then(m => ({ default: m.ShipOrderDialog })));
const ConfirmDeliveryDialog = lazy(() => import("@/components/domain/orders").then(m => ({ default: m.ConfirmDeliveryDialog })));
import { listOrders, updateOrderStatus, bulkUpdateOrderStatus, createOrderForKanban } from "@/server/functions/orders/orders";
import { listShipments } from "@/server/functions/orders/order-shipments";
import { useFulfillmentKanban, useUpdateFulfillmentOrderStatus, useBulkUpdateFulfillmentOrders, useAssignees } from "@/hooks/orders";
import { toast } from "@/lib/toast";
import { useQueryClient, useQuery, useMutation } from "@tanstack/react-query";
import { logger } from "@/lib/logger";
import { useFulfillmentPresence } from "@/components/domain/orders/fulfillment-dashboard";

// ============================================================================
// PERFORMANCE MONITORING
// ============================================================================

// SOTA SaaS: Performance monitoring for fulfillment operations
const onRenderCallback = (
  id: string,
  phase: 'mount' | 'update',
  actualDuration: number,
  baseDuration: number,
  startTime: number,
  commitTime: number
) => {
  // Log performance metrics
  const metrics = {
    componentId: id,
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime,
    domain: 'fulfillment-kanban',
  };

  if (actualDuration > 16) {
    logger.warn('Slow render detected in fulfillment kanban', metrics);

    // Send to performance monitoring service if available
    if (typeof window !== 'undefined' && (window as any).Sentry) {
      (window as any).Sentry.captureMessage(`Slow render: ${id}`, {
        level: 'warning',
        tags: {
          component: id,
          phase,
          domain: 'fulfillment-kanban',
        },
        extra: metrics,
      });
    }
  } else if (process.env.NODE_ENV === 'development') {
    logger.debug(`Fulfillment render: ${id}`, metrics);
  }
};

// ============================================================================
// ROUTE DEFINITION
// ============================================================================

export const Route = createFileRoute("/_authenticated/orders/fulfillment")({
  component: FulfillmentPage,
});

// ============================================================================
// MAIN COMPONENT
// ============================================================================

function FulfillmentPage() {
  const navigate = useNavigate();
  const queryClient = useQueryClient();

  // Dialog state for shipping operations
  const [shipDialogOpen, setShipDialogOpen] = useState(false);
  const [shipOrderId, setShipOrderId] = useState<string | null>(null);
  const [confirmDialogOpen, setConfirmDialogOpen] = useState(false);
  const [confirmShipmentId, setConfirmShipmentId] = useState<string | null>(null);

  // Dialog state for order creation
  const [createOrderDialogOpen, setCreateOrderDialogOpen] = useState(false);
  const [createOrderStage, setCreateOrderStage] = useState<string>('');

  // Dialog state for order editing
  const [editOrderDialogOpen, setEditOrderDialogOpen] = useState(false);
  const [editingOrder, setEditingOrder] = useState<any>(null);

  // Inline editing hook
  const inlineEdit = useOrderInlineEdit();

  // User presence tracking
  const { recordActivity, totalActiveUsers } = useFulfillmentPresence();

  // Available assignees for order assignment
  const { assignees: availableAssignees } = useAssignees();

  // Bulk operations dialog state
  const [bulkOperationsDialog, setBulkOperationsDialog] = useState<{
    open: boolean
    operation: any
    orders: any[]
  }>({
    open: false,
    operation: null,
    orders: [],
  });

  // Advanced filtering state with localStorage persistence
  const [filters, setFilters] = useState(() => {
    try {
      const saved = localStorage.getItem('fulfillment-kanban-filters');
      if (saved) {
        const parsedFilters = JSON.parse(saved);
        return {
          priority: parsedFilters.priority || 'all',
          status: parsedFilters.status || 'all',
          customerId: parsedFilters.customerId || 'all',
          dateRange: parsedFilters.dateRange || 'all',
          searchQuery: parsedFilters.searchQuery || '',
        };
      }
    } catch (error) {
      console.warn('Failed to load saved fulfillment filters:', error);
    }

    // Default filters
    return {
      priority: 'all' as const,
      status: 'all' as const,
      customerId: 'all' as const,
      dateRange: 'all' as const,
      searchQuery: '',
    };
  });

  // Save filters to localStorage whenever they change
  useEffect(() => {
    try {
      localStorage.setItem('fulfillment-kanban-filters', JSON.stringify(filters));
      // Record activity when filters change
      recordActivity();
    } catch (error) {
      console.warn('Failed to save fulfillment filters:', error);
    }
  }, [filters, recordActivity]);

  // Convert dateRange filter to actual dates
  const getDateRangeFilters = useCallback(() => {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    switch (filters.dateRange) {
      case 'today':
        return {
          dateFrom: today,
          dateTo: new Date(today.getTime() + 24 * 60 * 60 * 1000 - 1)
        };
      case 'this_week': {
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - today.getDay()); // Start of week (Sunday)
        const endOfWeek = new Date(startOfWeek);
        endOfWeek.setDate(startOfWeek.getDate() + 6); // End of week (Saturday)
        return {
          dateFrom: startOfWeek,
          dateTo: endOfWeek
        };
      }
      case 'overdue':
        return {
          dateFrom: undefined,
          dateTo: new Date(today.getTime() - 24 * 60 * 60 * 1000) // Yesterday
        };
      case 'upcoming': {
        const nextWeek = new Date(today);
        nextWeek.setDate(today.getDate() + 7);
        return {
          dateFrom: today,
          dateTo: nextWeek
        };
      }
      default:
        return { dateFrom: undefined, dateTo: undefined };
    }
  }, [filters.dateRange]);

  // Enhanced data fetching using new kanban hooks
  const {
    data: kanbanData,
    isLoading: loadingKanban,
    error: kanbanError,
    realtimeStatus,
    reconnectAttempts,
    reconnect
  } = useFulfillmentKanban({
    customerId: filters.customerId !== 'all' ? filters.customerId : undefined,
    dateFrom: dateFilters.dateFrom,
    dateTo: dateFilters.dateTo,
    search: filters.searchQuery,
    enabled: true,
  });

  // Fetch customers for filter dropdown
  const { data: customersData } = useQuery({
    queryKey: ['customers', 'list', { pageSize: 100 }],
    queryFn: () => getCustomers({
      data: { page: 1, pageSize: 100, sortBy: 'name', sortOrder: 'asc' }
    }),
    staleTime: 5 * 60 * 1000, // Cache for 5 minutes
  });

  const availableCustomers = customersData?.customers?.map(c => ({ id: c.id, name: c.name })) || [];

  // Fallback data fetching for backward compatibility (shipments)
  const { data: activeShipments, isLoading: loadingShipments } = useQuery({
    queryKey: ["shipments", "fulfillment", "active"],
    queryFn: async () => {
      const result = await listShipments({
        data: {
          page: 1,
          pageSize: 100,
          status: "in_transit",
        },
      });
      return result;
    },
    refetchInterval: 60000, // Poll every minute
  });

  // Enhanced mutation hooks
  const updateOrderStatusMutation = useUpdateFulfillmentOrderStatus({
    onSuccess: () => toast.success("Order status updated successfully"),
    onError: (error) => toast.error(`Failed to update order status: ${error.message}`),
  });

  const bulkUpdateOrdersMutation = useBulkUpdateFulfillmentOrders({
    onSuccess: () => toast.success("Bulk operation completed successfully"),
    onError: (error) => toast.error(`Bulk operation failed: ${error.message}`),
  });

  // Filter handlers
  const handleFiltersChange = useCallback((newFilters: typeof filters) => {
    setFilters(newFilters);
  }, []);

  // Navigation handlers
  const handleViewOrder = useCallback(
    (orderId: string) => {
      navigate({
        to: "/orders/$orderId",
        params: { orderId },
      });
    },
    [navigate]
  );

  // Enhanced order operations
  const handleAddOrder = useCallback((stage: string) => {
    recordActivity(); // Track user activity
    setCreateOrderStage(stage || 'to_allocate');
    setCreateOrderDialogOpen(true);
  }, [recordActivity]);

  const handleColumnAction = useCallback((stage: string, action: string) => {
    // Enhanced column actions: bulk operations, sorting, filtering
    console.log('Column action:', stage, action);

    if (action === 'bulk_allocate' && stage === 'to_allocate') {
      const orderIds = kanbanData?.stages.to_allocate.map(o => o.id) || [];
      if (orderIds.length > 0) {
        bulkUpdateOrdersMutation.mutateAsync({
          orderIds,
          status: 'picking',
          notes: 'Bulk allocated via kanban column action',
        });
      }
    }
  }, [kanbanData, bulkUpdateOrdersMutation]);

  // Shipping operation handlers
  const handleShipOrder = useCallback((orderId: string) => {
    setShipOrderId(orderId);
    setShipDialogOpen(true);
  }, []);

  const handleConfirmDelivery = useCallback((shipmentId: string) => {
    setConfirmShipmentId(shipmentId);
    setConfirmDialogOpen(true);
  }, []);

  const handleShipDialogClose = useCallback(() => {
    setShipDialogOpen(false);
    setShipOrderId(null);
  }, []);

  const handleConfirmDialogClose = useCallback(() => {
    setConfirmDialogOpen(false);
    setConfirmShipmentId(null);
  }, []);

  // Legacy mutations for backward compatibility (can be removed once fully migrated)
  const createOrderMutation = useMutation({
    mutationFn: async ({ customerId, targetStage, notes }: { customerId: string; targetStage: string; notes?: string }) => {
      return createOrderForKanban({
        data: { customerId, targetStage, notes },
      });
    },
    onSuccess: () => {
      toast.success("Order created successfully");
      queryClient.invalidateQueries({ queryKey: ["orders", "fulfillment"] });
    },
    onError: () => {
      toast.error("Failed to create order");
    },
  });

  // Enhanced fulfillment handlers using new hooks
  const handleOrderMove = useCallback(async (orderId: string, fromStage: string, toStage: string) => {
    recordActivity(); // Track user activity

    // Map kanban stage back to order status for server
    const stageToStatus: Record<string, string> = {
      to_allocate: 'confirmed',
      to_pick: 'picking',
      picking: 'picking',
      to_ship: 'picked',
      shipped_today: 'shipped',
    };

    const targetStatus = stageToStatus[toStage];
    if (!targetStatus) {
      console.error(`Invalid target stage: ${toStage}`);
      return;
    }

    await updateOrderStatusMutation.mutateAsync({
      orderId,
      status: targetStatus as any,
      notes: `Moved from ${fromStage} to ${toStage} via kanban drag`,
    });
  }, [updateOrderStatusMutation, recordActivity]);

  const handleBulkAllocate = useCallback((orderIds: string[]) => {
    // Find the selected orders for confirmation dialog
    const selectedOrders = transformedOrders.orders
      .filter(order => orderIds.includes(order.id))
      .map(order => ({
        id: order.id,
        orderNumber: order.orderNumber,
        customerName: order.customer?.name || 'Unknown Customer',
        total: order.total,
        currentStatus: order.status,
      }));

    setBulkOperationsDialog({
      open: true,
      operation: {
        type: 'allocate',
        title: 'Bulk Allocate Orders',
        description: 'Move selected orders to the picking stage for fulfillment.',
        confirmText: 'Allocate Orders',
        icon: () => null, // Will be handled by the dialog
        variant: 'default',
      },
      orders: selectedOrders,
    });
  }, [transformedOrders]);

  const handleBulkShip = useCallback((orderIds: string[]) => {
    // Find the selected orders for confirmation dialog
    const selectedOrders = transformedOrders.orders
      .filter(order => orderIds.includes(order.id))
      .map(order => ({
        id: order.id,
        orderNumber: order.orderNumber,
        customerName: order.customer?.name || 'Unknown Customer',
        total: order.total,
        currentStatus: order.status,
      }));

    setBulkOperationsDialog({
      open: true,
      operation: {
        type: 'ship',
        title: 'Bulk Ship Orders',
        description: 'Mark selected orders as shipped and update their status.',
        confirmText: 'Ship Orders',
        icon: () => null, // Will be handled by the dialog
        variant: 'default',
      },
      orders: selectedOrders,
    });
  }, [transformedOrders]);

  const handleBulkOperationConfirm = useCallback(async () => {
    const { operation, orders } = bulkOperationsDialog;
    const orderIds = orders.map(o => o.id);

    if (operation.type === 'allocate') {
      await bulkUpdateOrdersMutation.mutateAsync({
        orderIds,
        status: 'picking',
        notes: 'Bulk allocated via kanban board',
      });
    } else if (operation.type === 'ship') {
      await bulkUpdateOrdersMutation.mutateAsync({
        orderIds,
        status: 'shipped',
        notes: 'Bulk shipped via kanban board',
      });
    }
  }, [bulkOperationsDialog, bulkUpdateOrdersMutation]);

  const handleCreateOrder = useCallback(async (customerId: string, targetStage: string, notes?: string) => {
    await createOrderMutation.mutateAsync({ customerId, targetStage, notes });
  }, [createOrderMutation]);

  // Order editing handlers
  const handleEditOrder = useCallback((orderId: string) => {
    // Find the order in the current data
    const order = transformedOrders.orders.find(o => o.id === orderId);
    if (order) {
      setEditingOrder(order);
      setEditOrderDialogOpen(true);
    }
  }, [transformedOrders]);

  const handleSaveOrderEdit = useCallback(async (orderId: string, data: { priority: string; orderNumber: string; dueDate?: Date }) => {
    try {
      await updateOrderStatusMutation.mutateAsync({
        orderId,
        status: 'confirmed', // Keep current status, just update metadata
        notes: `Updated via inline edit: ${data.orderNumber}`,
      });
      toast.success('Order updated successfully');
      inlineEdit.stopEditing();
    } catch (error) {
      toast.error('Failed to update order');
      throw error;
    }
  }, [updateOrderStatusMutation, inlineEdit]);

  // Context menu handlers
  const handleChangeOrderPriority = useCallback(async (orderId: string, priority: string) => {
    try {
      // For now, we'll just show a toast - in a full implementation, you'd update the order metadata
      toast.success(`Order priority changed to ${priority}`);
    } catch (error) {
      toast.error('Failed to change priority');
    }
  }, []);

  const handleAssignOrder = useCallback(async (orderId: string, assigneeId: string) => {
    try {
      // For now, we'll just show a toast - in a full implementation, you'd update the order assignment
      toast.success(assigneeId ? 'Order assigned successfully' : 'Order unassigned');
    } catch (error) {
      toast.error('Failed to assign order');
    }
  }, []);

  const handleAssignOrder = useCallback(async (orderId: string, assigneeId: string | null) => {
    // TODO: Implement order assignment
    console.log(`Assigning order ${orderId} to assignee ${assigneeId}`);
    // This should update the order metadata with assignedTo field
  }, []);

  const handleMoveOrderToStage = useCallback(async (orderId: string, stage: string) => {
    // Map stage to status and move the order
    const stageToStatus: Record<string, string> = {
      to_allocate: 'confirmed',
      to_pick: 'picking',
      picking: 'picking',
      to_ship: 'picked',
      shipped_today: 'shipped',
    };

    const targetStatus = stageToStatus[stage];
    if (!targetStatus) {
      toast.error('Invalid stage');
      return;
    }

    await updateOrderStatusMutation.mutateAsync({
      orderId,
      status: targetStatus as any,
      notes: `Moved to ${stage} via context menu`,
    });
  }, [updateOrderStatusMutation]);

  const handleDuplicateOrder = useCallback(async (orderId: string) => {
    try {
      // For now, we'll just show a toast - in a full implementation, you'd duplicate the order
      toast.success('Order duplication not yet implemented');
    } catch (error) {
      toast.error('Failed to duplicate order');
    }
  }, []);

  const handleDeleteOrder = useCallback(async (orderId: string) => {
    if (window.confirm('Are you sure you want to delete this order? This action cannot be undone.')) {
      try {
        // For now, we'll just show a toast - in a full implementation, you'd delete the order
        toast.success('Order deletion not yet implemented');
      } catch (error) {
        toast.error('Failed to delete order');
      }
    }
  }, []);

  // Transform kanban data with client-side filtering
  const transformedOrders = useMemo(() => {
    if (!kanbanData) return { orders: [], total: 0 };

    // Flatten stages into order list
    const allOrders = [
      ...kanbanData.stages.to_allocate,
      ...kanbanData.stages.to_pick,
      ...kanbanData.stages.picking,
      ...kanbanData.stages.to_ship,
      ...kanbanData.stages.shipped_today,
    ];

    // Apply client-side filters (priority and status)
    let filteredOrders = allOrders;

    if (filters.priority !== 'all') {
      filteredOrders = filteredOrders.filter(order => order.priority === filters.priority);
    }

    if (filters.status !== 'all') {
      filteredOrders = filteredOrders.filter(order => order.status === filters.status);
    }

    return {
      orders: filteredOrders.map(order => ({
        id: order.id,
        orderNumber: order.orderNumber,
        customer: { name: order.customerName || 'Unknown Customer' },
        status: order.status,
        total: order.total,
        metadata: order.metadata,
        createdAt: order.createdAt,
        dueDate: order.dueDate,
        itemCount: order.itemCount,
      })),
      total: filteredOrders.length,
    };
  }, [kanbanData, filters.priority, filters.status]);

  return (
    <Profiler id="fulfillment-kanban" onRender={onRenderCallback}>
      <PageLayout variant="full-width">
        <PageLayout.Header
          title="Order Fulfillment"
          description="SOTA SaaS kanban board for order fulfillment workflow"
        />
        <PageLayout.Content>
          {kanbanError ? (
            // SOTA SaaS: Error boundary for kanban operations
            <div className="flex flex-col items-center justify-center h-96 text-center">
              <div className="text-red-500 mb-4">
                <h3 className="text-lg font-semibold">Fulfillment Board Error</h3>
                <p className="text-sm text-muted-foreground mt-2">
                  {kanbanError.message || 'Failed to load fulfillment data'}
                </p>
              </div>
              <Button
                onClick={() => window.location.reload()}
                className="min-h-[44px] min-w-[44px] md:h-10 md:w-auto md:min-h-0 md:min-w-0"
              >
                Reload Board
              </Button>
            </div>
          ) : (
            <FulfillmentDashboard
              orders={transformedOrders}
              shipments={activeShipments}
              isLoadingOrders={isLoading}
              isLoadingShipments={loadingShipments}
              exportFilters={filters}
              onViewOrder={handleViewOrder}
              onAddOrder={handleAddOrder}
              onColumnAction={handleColumnAction}
              onOrderMove={handleOrderMove}
              onBulkAllocate={handleBulkAllocate}
              onBulkShip={handleBulkShip}
              onCreateOrder={handleCreateOrder}
              onEditOrder={handleEditOrder}
              onSaveOrderEdit={handleSaveOrderEdit}
              onDuplicateOrder={handleDuplicateOrder}
              onDeleteOrder={handleDeleteOrder}
              onChangeOrderPriority={handleChangeOrderPriority}
              onAssignOrder={handleAssignOrder}
              onSaveOrderEdit={handleSaveOrderEdit}
              onMoveOrderToStage={handleMoveOrderToStage}
              availableCustomers={availableCustomers}
              availableAssignees={availableAssignees}
              realtimeStatus={realtimeStatus}
              reconnectAttempts={reconnectAttempts}
              onReconnect={reconnect}
              activeUserCount={totalActiveUsers}
              editingOrderId={inlineEdit.editingOrderId}
              onStartEdit={inlineEdit.startEditing}
              onCancelEdit={inlineEdit.stopEditing}
            />
          )}
        </PageLayout.Content>

        {/* Lazy-loaded Dialogs with Suspense Boundaries */}
        <Suspense fallback={null}>
          {/* Ship Order Dialog */}
          {shipOrderId && (
            <ShipOrderDialog
              open={shipDialogOpen}
              onOpenChange={handleShipDialogClose}
              orderId={shipOrderId}
              onSuccess={handleShipDialogClose}
            />
          )}

          {/* Confirm Delivery Dialog */}
          {confirmShipmentId && (
            <ConfirmDeliveryDialog
              open={confirmDialogOpen}
              onOpenChange={handleConfirmDialogClose}
              shipmentId={confirmShipmentId}
              onSuccess={handleConfirmDialogClose}
            />
          )}

          {/* Order Create Dialog */}
          <OrderCreateDialog
            open={createOrderDialogOpen}
            onOpenChange={setCreateOrderDialogOpen}
            stage={createOrderStage}
          />

          {/* Order Edit Dialog */}
          <OrderEditDialog
            open={editOrderDialogOpen}
            onOpenChange={setEditOrderDialogOpen}
            order={editingOrder}
          />

          {/* Bulk Operations Dialog */}
          <OrderBulkOperationsDialog
            open={bulkOperationsDialog.open}
            onOpenChange={(open) =>
              setBulkOperationsDialog(prev => ({ ...prev, open }))
            }
            operation={bulkOperationsDialog.operation}
            orders={bulkOperationsDialog.orders}
            onConfirm={handleBulkOperationConfirm}
            isLoading={bulkUpdateOrdersMutation.isPending}
          />
        </Suspense>
      </PageLayout>
    </Profiler>
  );
}
